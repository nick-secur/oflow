<html>
<head>
    <title>Optical flow detection in JavaScript</title>
    <style type="text/css">
        canvas {
            background-color: black;
        }
        video {
            background-color: blue;
        }
    </style>
    <script type="text/javascript" src="./colors.js"></script>
    <script type="text/javascript" src="../../dist/oflow.js"></script>
    <script type="text/javascript">
    function main() {
        var

            // parameterize zone size. the zone determines step size for comparisons.
            // Larger steps means fewer zones ...

            //zoneSize = 32,
            //zoneSize = 8,
            zoneSize = 4,

            videoElement = document.getElementById('videoOut'),
            videoWidth   = videoElement.videoWidth,
            videoHeight  = videoElement.videoHeight,
            canvas = document.getElementById('scene'),
            sceneCtx = canvas.getContext('2d'),
            sceneWidth = canvas.width,
            sceneHeight = canvas.height,
            flowCanvas = document.getElementById('flow-vector');

        var filteredFlow = new oflow.FilteredFlow( videoElement, zoneSize );

        filteredFlow.onCalculated( function (direction, filteredVideoData) {

            /**
             * render zones as vectors...
             */
            function renderZonesAsVectors()  {
                for(var i = 0; i < direction.zones.length; ++i) {
                    var zone = direction.zones[i];
                    sceneCtx.strokeStyle =  getDirectionalColor(zone.u, zone.v);
                    sceneCtx.beginPath();
                    sceneCtx.moveTo(zone.x,zone.y);
                    sceneCtx.lineTo((zone.x - zone.u), zone.y + zone.v);
                    sceneCtx.stroke();
                }
            }

            function getVectorMagnitude( zone ) {
                return ( Math.sqrt( (zone.u * zone.u) + (zone.v * zone.v) ) );
            }

            // todo:  try a denoise filter and see if it improves areas of detected movements ...

            /**
             * heuristic 1: only render a zone if it's vector magnitude exceeds threshold
             */
            function doRender( zone ) {
                const THRESHOLD = 5;
                let magnitude = getVectorMagnitude(zone);
                return( magnitude > THRESHOLD );
            }

            function renderZonesAsPixels()  {
                for(var i = 0; i < direction.zones.length; ++i) {
                    var zone = direction.zones[i];
                    if( doRender( zone ) ) {
                        sceneCtx.fillStyle =  getDirectionalColor(zone.u, zone.v);
                        sceneCtx.beginPath();
                        sceneCtx.rect( zone.x, zone.y, 3, 3);
                        sceneCtx.fill();
                    }
                }
            }

            function renderFlowVector() {
                let flowVectorCtx = flowCanvas.getContext('2d'),
                    flowVectorW = flowCanvas.width,
                    flowVectorH = flowCanvas.height;
                let origin = {
                    x: flowVectorW / 2,
                    y: flowVectorH / 2
                };
                flowVectorCtx.clearRect(0, 0, flowVectorW, flowVectorH);
                // drawLine (0, 0, u, v)
                flowVectorCtx.strokeStyle =  getDirectionalColor(direction.u, direction.v);
                flowVectorCtx.beginPath();
                flowVectorCtx.moveTo( origin.x, origin.y );
                flowVectorCtx.lineTo( (origin.x + (100 * direction.u) ), (origin.y + (100 * direction.v)) );
                flowVectorCtx.stroke();
            }

            sceneCtx.clearRect(0, 0, sceneWidth, sceneHeight);
            // TODO: RESUME HERE APPLY DENOISE FILTER
            // get video frame data as image object
            // sceneCtx.drawImage( videoElement, 0, 0 );

            // let srcData = sceneCtx.getImageData(0, 0, sceneWidth, sceneHeight);
            // let destData = sceneCtx.getImageData(0, 0, sceneWidth, sceneHeight);
            // oflow.RsImageFilters.denoise( srcData, destData, sceneWidth, sceneHeight, 4 );

            if( filteredVideoData && filteredVideoData.data ) {
                sceneCtx.putImageData(filteredVideoData, 0, 0);
            }


            renderZonesAsVectors();
            renderFlowVector();
        });
        filteredFlow.startCapture();
    }
    </script>
</head>
<body onload="main()" >

<!--src="./video/3DimensionalBox.mp4"-->
<!--src="./video/3MinuteLiquidVideo.mp4"-->
<!--src="./video/CenterWaves.mp4"-->
<!--src="./video/ms_fluid_mov.mp4"-->
<!--src="./video/ms_liquid_mov.mp4"-->
<!--src="./video/powder_test_01_7gSaltInBagInEnv.mp4"-->
<!--src="./video/pt_02.mp4"-->
<!--src="./video/LotteThatSilhouetteGirl_1920x1080_Clip01.mp4"-->

    <div >
        <video id='videoOut'
               width=384
               height=288

               src="./video/pt_02.mp4"

               controls=true
        ></video>
    </div>
    <div>
        <canvas id='scene'
                width=384
                height=288 ></canvas>
    </div>

    <div>
        <canvas id='flow-vector'
                width=100
                height=100 ></canvas>
    </div>

</body>
</html>